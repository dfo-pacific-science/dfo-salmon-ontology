# Auto-generated by scripts/extract-term-tables.py; do not edit manually.

# Scheme terms
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dcterms: <http://purl.org/dc/terms/>

SELECT DISTINCT ?term ?termLabel ?definition ?definitionSourceText ?definitionSourceLink ?related ?relatedLabel ?relation
WHERE {
  VALUES ?scheme { <https://w3id.org/dfoc/salmon#BiologicalBenchmarkAndIndicatorScheme> }
  ?term skos:inScheme ?scheme .
  ?term a skos:Concept .
  # Extract term label: prefer skos:prefLabel, fall back to rdfs:label, then use IRI fragment
  # Language filter ensures we only get English labels or untyped literals
  OPTIONAL {
    ?term skos:prefLabel ?prefLabelRaw .
    FILTER(LANG(?prefLabelRaw) = "" || LANGMATCHES(LANG(?prefLabelRaw), "en"))
  }
  OPTIONAL {
    ?term rdfs:label ?rdfsLabelRaw .
    FILTER(LANG(?rdfsLabelRaw) = "" || LANGMATCHES(LANG(?rdfsLabelRaw), "en"))
  }
  # COALESCE returns first non-null value: prefLabel > rdfs:label > IRI fragment
  BIND(COALESCE(?prefLabelRaw, ?rdfsLabelRaw, STRAFTER(STR(?term), "#")) AS ?termLabel) .

  # Extract scheme label (for scheme-based queries)
  OPTIONAL {
    ?scheme skos:prefLabel ?schemePref .
    FILTER(LANG(?schemePref) = "" || LANGMATCHES(LANG(?schemePref), "en"))
  }
  BIND(COALESCE(?schemePref, STRAFTER(STR(?scheme), "#")) AS ?schemeLabel) .

  # Extract definition: check multiple properties in priority order
  # 1. skos:definition (SKOS standard)
  # 2. rdfs:comment (RDF Schema standard)
  # 3. IAO_0000115 (Information Artifact Ontology definition property)
  OPTIONAL {
    ?term skos:definition ?defSKOS .
    FILTER(LANG(?defSKOS) = "" || LANGMATCHES(LANG(?defSKOS), "en"))
  }
  OPTIONAL {
    ?term rdfs:comment ?defRDFS .
    FILTER(LANG(?defRDFS) = "" || LANGMATCHES(LANG(?defRDFS), "en"))
  }
  OPTIONAL {
    ?term <http://purl.obolibrary.org/obo/IAO_0000115> ?defIAO .
    FILTER(LANG(?defIAO) = "" || LANGMATCHES(LANG(?defIAO), "en"))
  }
  # Use first available definition source
  BIND(COALESCE(?defSKOS, ?defRDFS, ?defIAO) AS ?definition) .

  # Extract definition source: text citation (IAO_0000119) or link (dcterms:source)
  # IAO_0000119 = "has definition source" (text citation)
  OPTIONAL {
    ?term <http://purl.obolibrary.org/obo/IAO_0000119> ?definitionSourceText .
    FILTER(LANG(?definitionSourceText) = "" || LANGMATCHES(LANG(?definitionSourceText), "en"))
  }
  # dcterms:source = Dublin Core source property (typically a URL)
  OPTIONAL {
    ?term dcterms:source ?definitionSourceLink .
  }

  # Extract related terms via three relationship types (UNION creates one result per relationship)
  # This allows a term to have multiple related terms, each with its relationship type
  OPTIONAL {
    # Broader term (parent concept in SKOS hierarchy)
    {
      ?term skos:broader ?related .
      BIND("skos:broader" AS ?relation) .
    }
    UNION
    # Narrower term (child concept in SKOS hierarchy)
    {
      ?term skos:narrower ?related .
      BIND("skos:narrower" AS ?relation) .
    }
    UNION
    # Subclass relationship (OWL/RDFS class hierarchy)
    {
      ?term rdfs:subClassOf ?related .
      BIND("rdfs:subClassOf" AS ?relation) .
    }
    # Extract label for the related term (same pattern as term label extraction)
    OPTIONAL {
      ?related skos:prefLabel ?relatedPref .
      FILTER(LANG(?relatedPref) = "" || LANGMATCHES(LANG(?relatedPref), "en"))
    }
    OPTIONAL {
      ?related rdfs:label ?relatedLabelRaw .
      FILTER(LANG(?relatedLabelRaw) = "" || LANGMATCHES(LANG(?relatedLabelRaw), "en"))
    }
  # Use first available label or fall back to IRI fragment
  BIND(COALESCE(?relatedPref, ?relatedLabelRaw, STRAFTER(STR(?related), "#")) AS ?relatedLabel) .
  }

}
ORDER BY LCASE(?termLabel) STR(?term) LCASE(COALESCE(?relatedLabel, "")) STR(COALESCE(?related, ""))

# Class terms (including subclasses)
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX dcterms: <http://purl.org/dc/terms/>

SELECT DISTINCT ?term ?termLabel ?definition ?definitionSourceText ?definitionSourceLink ?related ?relatedLabel ?relation
WHERE {
  VALUES ?baseClass { <https://w3id.org/dfoc/salmon#ReferencePoint> <https://w3id.org/dfoc/salmon#TargetOrLimitRateOrAbundance> <https://w3id.org/dfoc/salmon#IndexBased> <https://w3id.org/dfoc/salmon#ObservedRateOrAbundance> }
  # Include base classes and all their subclasses (transitive closure)
  # The * means zero or more steps, so it includes the base class itself
  ?term rdfs:subClassOf* ?baseClass .
  ?term a owl:Class .
  # Extract term label: prefer skos:prefLabel, fall back to rdfs:label, then use IRI fragment
  # Language filter ensures we only get English labels or untyped literals
  OPTIONAL {
    ?term skos:prefLabel ?prefLabelRaw .
    FILTER(LANG(?prefLabelRaw) = "" || LANGMATCHES(LANG(?prefLabelRaw), "en"))
  }
  OPTIONAL {
    ?term rdfs:label ?rdfsLabelRaw .
    FILTER(LANG(?rdfsLabelRaw) = "" || LANGMATCHES(LANG(?rdfsLabelRaw), "en"))
  }
  # COALESCE returns first non-null value: prefLabel > rdfs:label > IRI fragment
  BIND(COALESCE(?prefLabelRaw, ?rdfsLabelRaw, STRAFTER(STR(?term), "#")) AS ?termLabel) .

  # Extract scheme label (for scheme-based queries)
  OPTIONAL {
    ?scheme skos:prefLabel ?schemePref .
    FILTER(LANG(?schemePref) = "" || LANGMATCHES(LANG(?schemePref), "en"))
  }
  BIND(COALESCE(?schemePref, STRAFTER(STR(?scheme), "#")) AS ?schemeLabel) .

  # Extract definition: check multiple properties in priority order
  # 1. skos:definition (SKOS standard)
  # 2. rdfs:comment (RDF Schema standard)
  # 3. IAO_0000115 (Information Artifact Ontology definition property)
  OPTIONAL {
    ?term skos:definition ?defSKOS .
    FILTER(LANG(?defSKOS) = "" || LANGMATCHES(LANG(?defSKOS), "en"))
  }
  OPTIONAL {
    ?term rdfs:comment ?defRDFS .
    FILTER(LANG(?defRDFS) = "" || LANGMATCHES(LANG(?defRDFS), "en"))
  }
  OPTIONAL {
    ?term <http://purl.obolibrary.org/obo/IAO_0000115> ?defIAO .
    FILTER(LANG(?defIAO) = "" || LANGMATCHES(LANG(?defIAO), "en"))
  }
  # Use first available definition source
  BIND(COALESCE(?defSKOS, ?defRDFS, ?defIAO) AS ?definition) .

  # Extract definition source: text citation (IAO_0000119) or link (dcterms:source)
  # IAO_0000119 = "has definition source" (text citation)
  OPTIONAL {
    ?term <http://purl.obolibrary.org/obo/IAO_0000119> ?definitionSourceText .
    FILTER(LANG(?definitionSourceText) = "" || LANGMATCHES(LANG(?definitionSourceText), "en"))
  }
  # dcterms:source = Dublin Core source property (typically a URL)
  OPTIONAL {
    ?term dcterms:source ?definitionSourceLink .
  }

  # Extract related terms via three relationship types (UNION creates one result per relationship)
  # This allows a term to have multiple related terms, each with its relationship type
  OPTIONAL {
    # Broader term (parent concept in SKOS hierarchy)
    {
      ?term skos:broader ?related .
      BIND("skos:broader" AS ?relation) .
    }
    UNION
    # Narrower term (child concept in SKOS hierarchy)
    {
      ?term skos:narrower ?related .
      BIND("skos:narrower" AS ?relation) .
    }
    UNION
    # Subclass relationship (OWL/RDFS class hierarchy)
    {
      ?term rdfs:subClassOf ?related .
      BIND("rdfs:subClassOf" AS ?relation) .
    }
    # Extract label for the related term (same pattern as term label extraction)
    OPTIONAL {
      ?related skos:prefLabel ?relatedPref .
      FILTER(LANG(?relatedPref) = "" || LANGMATCHES(LANG(?relatedPref), "en"))
    }
    OPTIONAL {
      ?related rdfs:label ?relatedLabelRaw .
      FILTER(LANG(?relatedLabelRaw) = "" || LANGMATCHES(LANG(?relatedLabelRaw), "en"))
    }
  # Use first available label or fall back to IRI fragment
  BIND(COALESCE(?relatedPref, ?relatedLabelRaw, STRAFTER(STR(?related), "#")) AS ?relatedLabel) .
  }

}
ORDER BY LCASE(?termLabel) STR(?term) LCASE(COALESCE(?relatedLabel, "")) STR(COALESCE(?related, ""))
